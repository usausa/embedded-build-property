namespace BunnyTail.EmbeddedBuildProperty.Generator;

using System;
using System.Text;

using BunnyTail.EmbeddedBuildProperty.Generator.Helpers;
using BunnyTail.EmbeddedBuildProperty.Generator.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SourceGenerateHelper;

[Generator]
public sealed class BuildConstantGenerator : IIncrementalGenerator
{
    // ------------------------------------------------------------
    // Initialize
    // ------------------------------------------------------------

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var model = context.AnalyzerConfigOptionsProvider.Select((provider, _) =>
        {
            provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var ns);
            provider.GlobalOptions.TryGetValue("build_property.EmbeddedConstantClass", out var className);
            provider.GlobalOptions.TryGetValue("build_property.EmbeddedConstantValues", out var values);

            return new BuildConstantModel(
                ns ?? string.Empty,
                String.IsNullOrEmpty(className) ? "EmbeddedConstants" : className!,
                values ?? string.Empty);
        });

        context.RegisterImplementationSourceOutput(
            model,
            Execute);
    }

    // ------------------------------------------------------------
    // Generator
    // ------------------------------------------------------------

    private static void Execute(SourceProductionContext context, BuildConstantModel model)
    {
        if (String.IsNullOrEmpty(model.Values))
        {
            return;
        }

        var builder = new SourceBuilder();

        builder.AutoGenerated();
        builder.EnableNullable();
        builder.NewLine();

        // namespace
        if (!String.IsNullOrEmpty(model.Namespace))
        {
            builder.Namespace(model.Namespace);
            builder.NewLine();
        }

        // class
        builder
            .Indent()
            .Append("internal static class ")
            .Append(model.ClassName).
            NewLine();
        builder.BeginScope();

        var span = model.Values.AsSpan().Trim();

        var first = true;
        while (TryReadValueEntry(context, ref span, out var entry))
        {
            if (first)
            {
                first = false;
            }
            else
            {
                builder.NewLine();
            }

            var value = entry.Type == "string" ? $"@\"{entry.Value.Replace("\"", "\"\"")}\"" : (String.IsNullOrEmpty(entry.Value) ? "default!" : entry.Value);
            builder
                .Indent()
                .Append("public const ")
                .Append(entry.Type)
                .Append(' ')
                .Append(entry.Name)
                .Append(" = ")
                .Append(value)
                .Append(';')
                .NewLine();
        }

        builder.EndScope();

        var source = builder.ToString();
        context.AddSource("EmbeddedConstants.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    // ------------------------------------------------------------
    // Helper
    // ------------------------------------------------------------

    private static bool TryReadValueEntry(SourceProductionContext context, ref ReadOnlySpan<char> source, out (string Name, string Type, string Value) entry)
    {
        entry = default;

        if (source.IsEmpty)
        {
            return false;
        }

        var nameEnd = source.IndexOf('=');
        if (nameEnd <= 0)
        {
            context.ReportDiagnostic(new DiagnosticInfo(Diagnostics.InvalidConstValueName, null, string.Empty));
            return false;
        }

        var nameSpan = source.Slice(0, nameEnd);
        var afterName = source.Slice(nameEnd + 1);

        var typeEnd = afterName.IndexOf(':');
        if (typeEnd <= 0)
        {
            context.ReportDiagnostic(new DiagnosticInfo(Diagnostics.InvalidConstValueType, null, string.Empty));
            return false;
        }

        var typeSpan = afterName.Slice(0, typeEnd);
        var valueSpan = afterName.Slice(typeEnd + 1);

        var sb = new ValueStringBuilder(stackalloc char[256]);
        var i = 0;
        var escape = false;

        while (i < valueSpan.Length)
        {
            var c = valueSpan[i];

            if (escape)
            {
                sb.Append(c);
                escape = false;
                i++;
                continue;
            }

            if (c == '\\')
            {
                escape = true;
                i++;
                continue;
            }

            i++;

            if (c == ',')
            {
                break;
            }

            sb.Append(c);
        }

        source = source.Slice(nameEnd + 1 + typeEnd + 1 + i).TrimStart();

        entry = (nameSpan.Trim().ToString(), typeSpan.Trim().ToString(), sb.ToTrimString());
        return true;
    }
}
